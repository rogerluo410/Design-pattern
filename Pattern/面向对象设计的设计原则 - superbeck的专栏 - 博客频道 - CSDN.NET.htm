<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>面向对象设计的设计原则 - superbeck的专栏 - 博客频道 - CSDN.NET</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="在设计面向对象的程序的时，模式不是一定要套的，但是有一些原则最好是遵守。这些原则共有七个，包括：开闭原则、里氏代换原则、依赖倒转原则、合成/聚合复用原则、迪米特法则、接口隔离原则，单一职责原则。" />
<script src="http://static.blog.csdn.net/scripts/jquery.js" type="text/javascript"></script>
<script type="text/javascript" src="http://static.blog.csdn.net/scripts/ad.js?v=1.1"></script>
<link rel="Stylesheet" type="text/css" href="http://static.blog.csdn.net/skin/default/css/style.css?v=1.1" />
<link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="/superbeck/rss/list" />
<link rel="shortcut icon" href="/favicon.ico" />
<link type="text/css" rel="stylesheet" href="http://static.blog.csdn.net/scripts/SyntaxHighlighter/styles/default.css" />
</head>
<body>
<script src="http://csdnimg.cn/pubnav/js/pub_topnav_2011.js"type="text/javascript"></script>

<div id="container">
<div id="header">
    <div class="header">
        <div id="blog_title">
            <h1><a href="http://blog.csdn.net/superbeck">superbeck的专栏</a></h1>
            <h2>以小事始，方知大事之成败</h2>
            <div class="clear"></div>
        </div>
        <div class="clear"></div>
    </div>
</div>
<div id="navigator">
    <div class="navigator_bg"></div>
    <div class="navigator">
        <ul>
            <li id="btnContents"><a href="http://blog.csdn.net/superbeck?viewmode=contents"><span><img src="http://static.blog.csdn.net/images/ico_list.gif">目录视图</span></a></li>
            <li id="btnView"><a href="http://blog.csdn.net/superbeck?viewmode=list"><span><img src="http://static.blog.csdn.net/images/ico_summary.gif">摘要视图</span></a></li>
            <li id="btnRss"><a href="http://blog.csdn.net/superbeck/rss/list"><span><img src="http://static.blog.csdn.net/images/ico_rss.gif">订阅</span></a></li>
</ul>
    </div>
</div>
<script type="text/javascript">
    var username = "superbeck";
    var _blogger = username;
    var blog_address = "http://blog.csdn.net/superbeck";
    var static_host = "http://static.blog.csdn.net";
    var currentUserName = "";
</script>

<div id="body">
<div id="main">
<div class="main">
<div class="notice"> 

<a href="https://code.csdn.net/blog/12" target="_blank">
<font color=red>公告：博客新增直接引用代码功能</font></a>



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://www.csdn.net/article/2013-07-24/2816320" target="_blank"><font color=blue>专访谭海燕：移动互联网开发的那些事
</font></a>

&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://blog.csdn.net/csdnproduct/article/details/9495139
"target="_blank">
<font color=red>CSDN博客频道自定义域名、标签搜索功能上线啦！


 </font></a>

&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://blog.csdn.net/adali/article/details/9813651"target="_blank">
<font color=blue>独一无二的职位：开源社区经理 
 </font></a>




</div>
<div id="article_details" class="details">
    <div class="article_title">
    <span class="ico ico_type_Original"></span>
    <h3>
        <span class="link_title"><a href="/superbeck/article/details/5664633">
        面向对象设计的设计原则
        </a></span>
    </h3>
</div>

        
    <div class="article_manage">
        <span class="link_categories">
        分类：
            <a href="/superbeck/article/category/490099">设计/UML/MDA</a> 
        </span>
    <span class="link_postdate">2010-06-11 16:59</span>
    <span class="link_view" title="阅读次数">507人阅读</span>
    <span class="link_comments" title="评论次数"><a href="#comments">评论</a>(0)</span>
    <span class="link_collect"><a href="javascript:void(0);" onclick="javascript:collectArticle('面向对象设计的设计原则','5664633');return false;" title="收藏">收藏</a></span>
    <span class="link_report"><a href="#report"  onclick="javascript:report(5664633,2);return false;" title="举报">举报</a></span>
    
</div>
<div class="tag2box"><a href='http://blog.csdn.net/tag/details.html?tag=%e6%89%a9%e5%b1%95' target=_blank>扩展</a><a href='http://blog.csdn.net/tag/details.html?tag=interface' target=_blank>interface</a><a href='http://blog.csdn.net/tag/details.html?tag=extension' target=_blank>extension</a><a href='http://blog.csdn.net/tag/details.html?tag=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f' target=_blank>设计模式</a><a href='http://blog.csdn.net/tag/details.html?tag=%e7%bc%96%e7%a8%8b' target=_blank>编程</a><a href='http://blog.csdn.net/tag/details.html?tag=object' target=_blank>object</a></div>


    
<div id="article_content" class="article_content">
<p><span style="font-size: small;">在设计面向对象的程序的时，模式不是一定要套的，但是有一些原则最好是遵守。这些原则已知的有七个，包括：开闭原则、里氏代换原则、依赖倒转原则、合成/聚合复用原则、迪米特法则、接口隔离原则，单一职责原则。</span>

</p>
<p><span style="font-size: medium;"><strong>原则简介</strong>

</span>

</p>
<p><span style="font-size: small;">其中Robert C. Martin引入了SOLID的说法，包括了其中的五个原则。另外两个，这里把他们算成额外的两个规则。具体如下。</span>

</p>
<p><span style="font-size: small;"><strong>S</strong>

. Single Responsibility Principle - SRP<br />

An object should have only a single responsibility.<br />

<br />

<strong>O</strong>

</span>

<span style="font-size: small;">
. Open-Closed Principle - OCP<br />

Software entities should be opened for extension, but closed for modification.<br />

<br />

<strong>L</strong>

</span>

<span style="font-size: small;">
. Liskvo Substitution Principle - LSP<br />

If S is a subtype of T, the objects of T in a program may be replaced by objects of Type S.<br />

<br />

<strong>I</strong>

</span>

<span style="font-size: small;">
. Interface Segregation Principle - ISP<br />

many client specific interfaces are better than one general purpose interface.<br />

<br />

<strong>D</strong>

</span>

<span style="font-size: small;">
. Dependency Inversion Principle - DIP<br />

Depend upon abstractions. Do not depend upon concretions.<br />

Program to an interface, not an implementation.<br />

<br />

<strong>Ex1</strong>

</span>

<span style="font-size: small;">
. Law of Demeter - LoD<br />

&nbsp; -- Principle of Least Knowledge<br />

A given object should assume as little as possible about the structure or properties of anything else.<br />

<br />

<strong>Ex2</strong>

</span>

<span style="font-size: small;">
. Composite/Aggregate Reuse Principle - CARP<br />

Use most composition and aggregation, less inheritance.</span>

</p>
<p><span style="font-size: small;">按照个人理解，把这七个原则分成了以下两个部分。</span>

</p>
<p><span style="font-size: small;">Design Method: SRP ISP DIP CARP<br />

Design Goal:&nbsp;&nbsp; OCP LSP LoD</span>

</p>
<p><span style="font-size: medium;"><strong>各规则详细(本部分为转载)
</strong>

</span>

</p>
<div style="text-indent: 21pt;"><span style="font-size: small;">正如牛顿三大定律在经典力学中的位置一样，&ldquo;开-闭&rdquo;原则（Open-Closed 
Principle）是面向对象的可复用设计（Object Oriented 
Design或OOD）的基石。其他设计原则（里氏代换原则、依赖倒转原则、合成/聚合复用原则、迪米特法则、接口隔离原则）是实现&ldquo;开-闭&rdquo;原则的手段
和工具。</span>

</div>
<div><span style="font-size: small;">&nbsp;</span>

</div>
<div><span style="font-size: small;"><strong>一、&ldquo;开-</strong>

<strong>闭&rdquo;原则（Open-Closed Principle,OCP</strong>

<strong>）</strong>

</span>

</div>
<div><span style="font-size: small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>1.1</strong>

<strong>&ldquo;开-</strong>

<strong>闭&rdquo;
原则的定义及优点</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">1）定义：一个软件实体应当对扩展开放，对修改关闭( Software 
entities should be open for extension,but closed for 
modification.)。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">2）满足&ldquo;开-闭&rdquo;原则的系统的优点</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">a)通过扩展已有的软件系统，可以提供新的行为，以满足对软件的新需求，使变化中的软
件系统有一定的适应性和灵活性。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">b)已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有
一定的稳定性和延续性。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">c)这样的系统同时满足了可复用性与可维护性。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>1.2</strong>

<strong>如何实现&ldquo;开-</strong>

<strong>闭&rdquo;
原则</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">在面向对象设计中，不允许更改的是系统的抽象层，而允许扩展的是系统的实现层。换言
之，定义一个一劳永逸的抽象设计层，允许尽可能多的行为在实现层被实现。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">解决问题关键在于抽象化，抽象化是面向对象设计的第一个核心本质。 </span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">对一个事物抽象化，实质上是在概括归纳总结它的本质。抽象让我们抓住最最重要的东西，
从更高一层去思考。这降低了思考的复杂度，我们不用同时考虑那么多的东西。换言之，我们封装了事物的本质，看不到任何细节。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">在面向对象编程中，通过抽象类及接口，规定了具体类的特征作为抽象层，相对稳定，不需
更改，从而满足&ldquo;对修改关闭&rdquo;；而从抽象类导出的具体类可以改变系统的行为，从而满足&ldquo;对扩展开放&rdquo;。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">对实体进行扩展时，不必改动软件的源代码或者二进制代码。关键在于抽象。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>1.3</strong>

<strong>对可变性的封装原则</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">&ldquo;开-闭&rdquo;原则也就是&ldquo;对可变性的封装原则&rdquo;（Principle of 
Encapsulation of Variation 
，EVP）。即找到一个系统的可变因素，将之封装起来。换言之，在你的设计中什么可能会发生变化，应使之成为抽象层而封装，而不是什么会导致设计改变才封
装。</span>

</div>
<div><span style="font-size: small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ldquo;对可变性的封装原则&rdquo;意味着：</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">a)一种可变性不应当散落在代码的许多角落，而应当被封装到一个对象里面。同一可变性
的不同表象意味着同一个继承等级结构中的具体子类。因此，此处可以期待继承关系的出现。继承是封装变化的方法，而不仅仅是从一般的对象生成特殊的对象。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">b)一种可变性不应当与另一种可变性混合在一起。作者认为类图的继承结构如果超过两
层，很可能意味着两种不同的可变性混合在了一起。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">使用&ldquo;可变性封装原则&rdquo;来进行设计可以使系统遵守&ldquo;开-闭&rdquo;原则。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">即使无法百分之百的做到&ldquo;开-闭&rdquo;原则，但朝这个方向努力，可以显著改善一个系统的结
构。</span>

</div>
<div><span style="font-size: small;"><strong>二、里氏代换原则（Liskov Substitution Principle, LSP）</strong>

</span>

</div>
<div style="background: none repeat scroll 0% 0% white; text-indent: 21pt;"><span style="font-size: small;"><strong>2.1</strong>

<strong>概念</strong>

</span>

</div>
<div style="background: none repeat scroll 0% 0% white; text-indent: 21pt;"><span style="font-size: small;">定义：<span style="color: black;">如果对每一个类型为</span>

<span style="color: black;">T1</span>

<span style="color: black;">的对象</span>

<span style="color: black;">O1</span>

<span style="color: black;">，都有类型为</span>

<span style="color: black;">T2 </span>

<span style="color: black;">的对象</span>

<span style="color: black;">O2</span>

<span style="color: black;">，使得以</span>

<span style="color: black;">T1</span>

<span style="color: black;">定义的所有程序</span>

<span style="color: black;">P</span>

<span style="color: black;">在所有的对象</span>

<span style="color: black;">O1</span>

<span style="color: black;">都代换为</span>

<span style="color: black;">O2</span>

<span style="color: black;">时，程序</span>

<span style="color: black;">P</span>

<span style="color: black;">的行为没有变化，那么类型</span>

<span style="color: black;">T2</span>

<span style="color: black;">是类型</span>

<span style="color: black;">T1</span>

<span style="color: black;">的子类型。</span>

</span>

</div>
<div style="background: none repeat scroll 0% 0% white; text-indent: 21pt;"><span style="font-size: small;"><span style="color: black;">即，一个软件实体如果使用的是一个基类的话，那么一
定适用于其子类。而且它觉察不出基类对象和子类对象的区别。</span>

也就是说,在软件里面,把基类都替换成它的子类,程序的行为没有变化。</span>

</div>
<div style="background: none repeat scroll 0% 0% white; text-indent: 21pt;"><span style="font-size: small;"><span style="color: black;">反过来的代换不成立，如果一个软件实体使用的是一个
子类的话，那么它不一定适用于基类。</span>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">任何基类可以出现的地方，子类一定可以出现。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">基于契约的设计、抽象出公共部分作为抽象基类的设计。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>2.2</strong>

<strong>里氏代换原则与&ldquo;开-</strong>

<strong>闭&rdquo;
原则的关系</strong>

</span>

</div>
<div><span style="font-size: small;">&nbsp;&nbsp;&nbsp; 实现&ldquo;开-闭&rdquo;原则的关键步骤是抽象化。基类与子类之间的继承关系就是抽象化的体现。因此里氏代换原则是对
实现抽象化的具体步骤的规范。</span>

</div>
<div><span style="font-size: small;">&nbsp;&nbsp;&nbsp; 违反里氏代换原则意味着违反了&ldquo;开-闭&rdquo;原则，反之未必。</span>

</div>
<div><span style="font-size: small;"><strong>三、 </strong>

<strong>依赖倒转原则</strong>

<strong>（</strong>

<strong>dependence
 inversion principle, DIP</strong>

<strong>）</strong>

</span>

</div>
<div><span style="font-size: small;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.1</strong>

<strong>概念</strong>

</span>

</div>
<div style="text-indent: 5.25pt;"><span style="font-size: small;">&nbsp;&nbsp; <strong>依赖倒转原则</strong>

就
是要依赖于抽象，不要依赖于实现。（Abstractions should not depend upon details. Details 
should depend upon abstractions.）要针对接口编程，不要针对实现编程。（Program to an 
interface, not an implementation.）</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">也就是说应当使用接口和抽象类进行变量类型声明、参数类型声明、方法返还类型说明，以
及数据类型的转换等。而不要用具体类进行变量的类型声明、参数类型声明、方法返还类型说明，以及数据类型的转换等。要保证做到这一点，一个具体类应当只实
现接口和抽象类中声明过的方法，而不要给出多余的方法。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">传统的过程性系统的设计办法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于
具体层次。倒转原则就是把这个错误的依赖关系倒转过来。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">面向对象设计的重要原则是创建抽象化，并且从抽象化导出具体化，具体化给出不同的实
现。继承关系就是一种从抽象化到具体化的导出。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">抽象层包含的应该是应用系统的商务逻辑和宏观的、对整个系统来说重要的战略性决定，是
必然性的体现。具体层次含有的是一些次要的与实现有关的算法和逻辑，以及战术性的决定，带有相当大的偶然性选择。具体层次的代码是经常变动的，不能避免出
现错误。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">从复用的角度来说，高层次的模块是应当复用的，而且是复用的重点，因为它含有一个应用
系统最重要的宏观商务逻辑，是较为稳定的。而在传统的过程性设计中，复用则侧重于具体层次模块的复用。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">依赖倒转原则则是对传统的过程性设计方法的&ldquo;倒转&rdquo;，是高层次模块复用及其可维护性的
有效规范。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">特例：对象的创建过程是违背&ldquo;开&mdash;闭&rdquo;原则以及依赖倒转原则的，但通过工厂模式，能很
好地解决对象创建过程中的依赖倒转问题。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>3.2</strong>

<strong>关系</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">&ldquo;开-闭&rdquo;原则与依赖倒转原则是目标和手段的关系。如果说开闭原则是目
标,依赖倒转原则是到达&quot;开闭&quot;原则的手段。如果要达到最好的&quot;开闭&quot;原则,就要尽量的遵守依赖倒转原则，依赖倒转原则是对&quot;抽象化&quot;的最好规范。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">里氏代换原则是依赖倒转原则的基础，依赖倒转原则是里氏代换原则的重要补充。</span>

</div>
<div style="text-indent: 21.1pt;"><span style="font-size: small;"><strong>3.3</strong>

<strong>耦合（或者依赖）关系
的种类：</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">零耦合（Nil Coupling）关系：两个类没有耦合关系</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">具体耦合（Concrete 
Coupling）关系：发生在两个具体的（可实例化的）类之间，经由一个类对另一个具体类的直接引用造成。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">抽象耦合（Abstract 
Coupling）关系：发生在一个具体类和一个抽象类（或接口）之间，使两个必须发生关系的类之间存有最大的灵活性。</span>

</div>
<div style="text-indent: 21.1pt;"><span style="font-size: small;"><strong>3.3.1如何把握耦合</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">我们应该尽可能的避免实现继承，原因如下：</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">1 失去灵活性，使用具体类会给底层的修改带来麻烦。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">2 
耦合问题，耦合是指两个实体相互依赖于对方的一个量度。程序员每天都在(有意识地或者无意识地)做出影响耦合的决定：类耦合、API耦合、应用程序耦合等
等。在一个用扩展的继承实现系统中，派生类是非常紧密的与基类耦合，而且这种紧密的连接可能是被不期望的。如B extends A 
，当B不全用A中的所有methods时，这时候，B调用的方法可能会产生错误!</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">我们必须客观的评价耦合度，系统之间不可能总是松耦合的，那样肯定什么也做不了。</span>

</div>
<div style="text-indent: 21.1pt;"><span style="font-size: small;"><strong>3.3.2我们决定耦合的程度的依据何在呢</strong>

？</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">简单的说，就是根据需求的稳定性，来决定耦合的程度。对于稳定性高的需求，不容易发生
变化的需求，我们完全可以把各类设计成紧耦合的(我们虽然讨论类之间的耦合度，但其实功能块、模块、包之间的耦合度也是一样的)，因为这样可以提高效率，
而且我们还可以使用一些更好的技术来提高效率或简化代码，例如c# 
中的内部类技术。可是，如果需求极有可能变化，我们就需要充分的考虑类之间的耦合问题，我们可以想出各种各样的办法来降低耦合程度，但是归纳起来，不外乎
增加抽象的层次来隔离不同的类，这个抽象层次可以是抽象的类、具体的类，也可以是接口，或是一组的类。我们可以用一句话来概括降低耦合度的思想：&quot;针对接
口编程，而不是针对实现编程。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">在我们进行编码的时候，都会留下我们的指纹，如public的多少，代码的格式等等。
我们可以耦合度量评估重新构建代码的风险。因为重新构建实际上是维护编码的一种形式，维护中遇到的那些麻烦事在重新构建时同样会遇到。我们知道在重新构建
之后，最常见的随机bug大部分都是不当耦合造成的 。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">如果不稳定因素越大，它的耦合度也就越大。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">某类的不稳定因素=依赖的类个数/被依赖的类个数</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">依赖的类个数＝ 在编译此类的时被编译的其它类的个数总和</span>

</div>
<div style="text-indent: 21.1pt;"><span style="font-size: small;"><strong>3.3.3怎样将大系统拆分成小系统</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">解决这个问题的一个思路是将许多类集合成一个更高层次的单位,形成一个高内聚、低耦合
的类的集合，这是我们设计过程中应该着重考虑的问题！</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">耦合的目标是维护依赖的单向性，有时我们也会需要使用坏的耦合。在这种情况下，应当小
心记录下原因，以帮助日后该代码的用户了解使用耦合真正的原因。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>3.4</strong>

<strong>怎样做到依赖倒转？</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">以抽象方式耦合是依赖倒转原则的关键。抽象耦合关系总要涉及具体类从抽象类继承，并且
需要保证在任何引用到基类的地方都可以改换成其子类，因此，里氏代换原则是依赖倒转原则的基础。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">在抽象层次上的耦合虽然有灵活性，但也带来了额外的复杂性，如果一个具体类发生变化的
可能性非常小，那么抽象耦合能发挥的好处便十分有限，这时可以用具体耦合反而会更好。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">层次化：所有结构良好的面向对象构架都具有清晰的层次定义，每个层次通过一个定义良好
的、受控的接口向外提供一组内聚的服务。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">依赖于抽象：建议不依赖于具体类，即程序中所有的依赖关系都应该终止于抽象类或者接
口。尽量做到：</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">1、任何变量都不应该持有一个指向具体类的指针或者引用。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">2、任何类都不应该从具体类派生。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">3、任何方法都不应该覆写它的任何基类中的已经实现的方法。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>3.5</strong>

<strong>依赖倒转原则的优缺点</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">依赖倒转原则虽然很强大，但却最不容易实现。因为依赖倒转的缘故，对象的创建很可能要
使用对象工厂，以避免对具体类的直接引用，此原则的使用可能还会导致产生大量的类，对不熟悉面向对象技术的工程师来说，维护这样的系统需要较好地理解面向
对象设计。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">依赖倒转原则假定所有的具体类都是会变化的，这也不总是正确。有一些具体类可能是相当
稳定，不会变化的，使用这个具体类实例的应用完全可以依赖于这个具体类型，而不必为此创建一个抽象类型。</span>

</div>
<div><span style="font-size: small;"><strong>四、合成/</strong>

<strong>聚合复用原则（</strong>

<strong>Composite/Aggregate
 Reuse Principle</strong>

<strong>或</strong>

<strong>CARP</strong>

<strong>）</strong>

</span>

</div>
<div><span style="font-size: small;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.1</strong>

<strong>概念</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">定义：在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过
向这些对象的委派达到复用这些对象的目的。</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;">应首先使用合成/聚合，合成/聚合则使系统灵活，其次才考虑继承，达到复用的目
的。而使用继承时，要严格遵循里氏代换原则。有效地使用继承会有助于对问题的理解，降低复杂度，而滥用继承会增加系统构建、维护时的难度及系统的复杂度。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">如果两个类是&ldquo;Has-a&rdquo;关系应使用合成、聚合，如果是&ldquo;Is-a&rdquo;关系可使用继
承。&quot;Is-A&quot;是严格的分类学意义上定义，意思是一个类是另一个类的&quot;一种&quot;。而&quot;Has-A&quot;则不同，它表示某一个角色具有某一项责任。</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;"><strong>4.2</strong>

<strong>什么是合成？什么是
聚合？</strong>

</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;">合成（Composition）和聚合（Aggregation）都是关联
（Association）的特殊种类。</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;">聚合表示整体和部分的关系，表示&ldquo;拥有&rdquo;。如奔驰S360汽车，对奔驰S360
引擎、奔驰S360轮胎的关系是聚合关系，离开了奔驰S360汽车，引擎、轮胎就失去了存在的意义。在设计中, 
聚合不应该频繁出现，这样会增大设计的耦合度。</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;">合成则是一种更强的&ldquo;拥有&rdquo;，部分和整体的生命周期一样。合成的新的对象完全支
配其组成部分，包括它们的创建和湮灭等。一个合成关系的成分对象是不能与另一个合成关系共享的。</span>

</div>
<div><span style="font-size: small;">&nbsp;&nbsp;&nbsp; 换句话说，合成是值的聚合（Aggregation by 
Value），而一般说的聚合是引用的聚合（Aggregation by Reference）。</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;">明白了合成和聚合关系，再来理解合成/聚合原则应该就清楚了，要避免在系统设计
中出现，一个类的继承层次超过3层，则需考虑重构代码，或者重新设计结构。当然最好的办法就是考虑使用合成/聚合原则。</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;"><strong>4.3</strong>

<strong>通过合成/</strong>

<strong>聚
合的优缺点</strong>

</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;"><strong>优点：</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">1) 新对象存取成分对象的唯一方法是通过成分对象的接口。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">2) 这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">3) 这种复用支持包装。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">4) 这种复用所需的依赖较少。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">5) 每一个新的类可以将焦点集中在一个任务上。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">6) 
这种复用可以在运行时间内动态进行，新对象可以动态的引用与成分对象类型相同的对象。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">7) 作为复用手段可以应用到几乎任何环境中去。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>缺点:</strong>

就是系统中会有较多的对象需要管理。</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;"><strong>4.4</strong>

<strong>通过继承来进行复用
的优缺点</strong>

</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;"><strong>优点：</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">新的实现较为容易，因为超类的大部分功能可以通过继承的关系自动进入子类。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">修改和扩展继承而来的实现较为容易。</span>

</div>
<div><span style="font-size: small;">&nbsp;&nbsp;&nbsp; <strong>缺点</strong>

：</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">继承复用破坏包装，因为继承将超类的实现细节暴露给子类。由于超类的内部细节常常是对
于子类透明的，所以这种复用是透明的复用，又称&ldquo;白箱&rdquo;复用。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">如果超类发生改变，那么子类的实现也不得不发生改变。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">从超类继承而来的实现是静态的，不可能在运行时间内发生改变，没有足够的灵活性。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">继承只能在有限的环境中使用。</span>

</div>
<div><span style="font-size: small;"><strong>五、 </strong>

<strong>迪米特法则（</strong>

<strong>Law of Demeter</strong>

<strong>，</strong>

<strong>LoD</strong>

）</span>

</div>
<div><span style="font-size: small;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.1</strong>

<strong>概述</strong>

</span>

</div>
<div><span style="font-size: small;">&nbsp;&nbsp;&nbsp; 定义：一个软件实体应当尽可能少的与其他实体发生相互作用。</span>

</div>
<div><span style="font-size: small;">&nbsp;&nbsp;&nbsp; 这样，当一个模块修改时，就会尽量少的影响其他的模块。扩展会相对容易。</span>

</div>
<div><span style="font-size: small;">&nbsp;&nbsp;&nbsp; 这是对软件实体之间通信的限制。它要求限制软件实体之间通信的宽度和深度。</span>

</div>
<div style="margin-left: 21pt;"><span style="font-size: small;"><strong>5.2</strong>

<strong>迪米特法则的其他表述：</strong>

</span>

</div>
<div style="margin-left: 21pt;"><span style="font-size: small;">1）只与你直接的朋友们通信。</span>

</div>
<div style="margin-left: 21pt;"><span style="font-size: small;">2）不要跟&ldquo;陌生人&rdquo;说话。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">3）每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的
软件单位。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>5.3</strong>

<strong>狭义的迪米特法则</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一
个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">朋友圈的确定</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">&ldquo;朋友&rdquo;条件：</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">1）当前对象本身（this）</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">2）以参量形式传入到当前对象方法中的对象</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">3）当前对象的实例变量直接引用的对象</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">4）当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">5）当前对象所创建的对象</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">任何一个对象，如果满足上面的条件之一，就是当前对象的&ldquo;朋友&rdquo;；否则就是&ldquo;陌生
人&rdquo;。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">缺点：会在系统里造出大量的小方法，散落在系统的各个角落。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">与依赖倒转原则互补使用</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>5.4</strong>

<strong>狭义的迪米特法则的缺点：</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的商务逻辑无关。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">遵循类之间的迪米特法则会是一个系统的局部设计简化，因为每一个局部都不会和远距离的
对象有直接的关联。但是，这也会造成系统的不同模块之间的通信效率降低，也会使系统的不同模块之间不容易协调。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>5.5</strong>

<strong>迪米特法则与设计模式</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">门面（外观）模式和调停者（中介者）模式实际上就是迪米特法则的具体应用。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>5.6</strong>

<strong>广义的迪米特法则</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">迪米特法则的主要用意是控制信息的过载。在将迪米特法则运用到系统设计中时，要注意下
面的几点：</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">1）在类的划分上，应当创建有弱耦合的类。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">2）在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">3）在类的设计上，只要有可能，一个类应当设计成不变类。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">4）在对其他类的引用上，一个对象对其对象的引用应当降到最低。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>5.7</strong>

<strong>广义迪米特法则在类的设计
上的体现</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">1）优先考虑将一个类设置成不变类</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">2）尽量降低一个类的访问权限</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">3）谨慎使用Serializable</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">4）尽量降低成员的访问权限</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">5）取代C Struct</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">迪米特法则又叫作最少知识原则（Least Knowledge 
Principle或简写为LKP），就是说一个对象应当对其他对象有尽可能少的了解。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;"><strong>5.8</strong>

<strong>如何实现迪米特法则</strong>

</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">迪米特法则的主要用意是控制信息的过载，在将其运用到系统设计中应注意以下几点：</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">1) 在类的划分上，应当创建有弱耦合的类。类之间的耦合越弱，就越有利于复用。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">2) 
在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界间接访问自己的属性。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">3) 在类的设计上，只要有可能，一个类应当设计成不变类。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">4) 在对其它对象的引用上，一个类对其它对象的引用应该降到最低。</span>

</div>
<div><span style="font-size: small;"><strong>六、 </strong>

<strong>接口隔离原则（</strong>

<strong>interface&nbsp;separate
 principle, ISP</strong>

<strong>）</strong>

</span>

</div>
<div><span style="font-size: small;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.1</strong>

<strong>概念</strong>

</span>

</div>
<div><span style="font-size: small;">&nbsp;&nbsp;&nbsp; 接口隔离原则：使用多个专门的接口比使用单一的总接口要好。也就是说，一个类对另外一个类的依赖性应当是建
立在最小的接口上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">这里的&quot;接口&quot;往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅
是一种逻辑上的抽象；另外一种是指某种语言具体的&quot;接口&quot;定义，有严格的定义和结构。比如c# 
语言里面的Interface结构。对于这两种不同的含义，ISP的表达方式以及含义都有所不同。(上面说的一个类型，可以理解成一个类，我们定义了一个
类，也就是定义了一种新的类型)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">当我们把&quot;接口&quot;理解成一个类所提供的所有方法的特征集合的时候，这就是一种逻辑上的
概念。接口的划分就直接带来类型的划分。这里，我们可以把接口理解成角色，一个接口就只是代表一个角色，每个角色都有它特定的一个接口，这里的这个原则可
以叫做&quot;角色隔离原则&quot;。</span>

</div>
<div style="text-indent: 21pt;"><span style="font-size: small;">如果把&quot;接口&quot;理解成狭义的特定语言的接口，那么ISP表达的意思是说，对不同的客户
端，同一个角色提供宽窄不同的接口，也就是定制服务，个性化服务。就是仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来。</span>

</div>
<div><span style="font-size: small;">&nbsp;&nbsp; &nbsp;应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</span>

</div>
<div style="text-indent: 5.25pt;"><span style="font-size: small;">&nbsp;&nbsp;这也是对软件实体之间通信的限制。但它限制的只是通信的宽度，就是说通信要尽
可能的窄。</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;">遵循迪米特法则和接口隔离原则，会使一个软件系统功能扩展时，修改的压力不会传
到别的对象那里。 </span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;"><strong>6.2</strong>

<strong>如何实现接口隔离原
则</strong>

</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;">不应该强迫用户依赖于他们不用的方法。</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;">1、利用委托分离接口。</span>

</div>
<div style="text-indent: 21.75pt;"><span style="font-size: small;">2、利用多继承分离接口。</span>

</div>
<div><strong>七、单一职责原则(SRP)</strong>

</div>
<p><span style="font-size: small;">单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。也就是说，不要把变化原因各不相同的职责放在一起，因为不同的变化会影响到不相干的职责。再通俗一点地说就是，不该你管的事情你不要管，管好自己的事情就可以了，多管闲事害了自己也害了别人。<br />

<br />

在软件设计中，如果一个类承担的职责过多，就等于吧这些职责耦合在一起，而一个职责的变化可能会削弱和抑制这个类完成其他职责的能力。这耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</span>

<span style="font-size: small;"><br />

<br />

软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果多于一个的动机去改变一个类，那么这个类就具有多余一个的职责，就应该要考虑类的职责分离。</span>

</p>
<p><span style="font-size: medium;"><strong>小结</strong>

</span>

</p>
<p><span style="font-size: small;">在我们进行面向对象系统的设计时，可以不去特意的考虑使用哪些设计模式，但是一定要尽量遵守这些设计原则。这样做的话，即使是设计经验不足，也比较容易设
计出易扩展的系统，并且可能自然的实现了某些模式。这种情况，恐怕算是很理想的一种设计了。</span>

</p>
<p><span style="font-size: medium;"><strong>参考资料</strong>

</span>

</p>
<p><span style="font-size: small;">1. 各规则详细的转载来源：<br />

 http://dev.csdn.net/author/hotmailmsn/67b483ad2819482682f1cd2f542bcd67.html<br />

 http://www.cnblogs.com/jimmypony/archive/2008/09/16/1291462.html<br />

2. http://en.wikipedia.org/wiki/Solid_%28object-oriented_design%29</span>

</p>
<p><span style="font-size: small;"><br />

</span>

</p>
</div>

<div class="share_buttons" id="sharePanel"></div>
<!--192.168.100.34-->
<div class="article_next_prev">
    <li class="prev_article"><span>上一篇：</span><a href="/superbeck/article/details/5660268">为什么上传文件的表单里要加个属性 enctype</a></li>
    <li class="next_article"><span>下一篇：</span><a href="/superbeck/article/details/5721382">eclipse上的几个Velocity插件</a></li>
</div>


    
</div>
<div id="ad_cen">
<script type="text/javascript" >BAIDU_CLB_SLOT_ID = "117306";</script>
<script type="text/javascript" src="http://cbjs.baidu.com/js/o.js"></script>
</div>
<script type="text/javascript">
    //new Ad(4, 'ad_cen');
</script>
<div id="comment_title" class="panel_head">查看评论<a name="comments"></a></div>
<div id="comment_list"></div>
<div id="comment_bar"></div>
<div id="comment_form"></div>
<div class="announce">* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a name="reply"></a><a name="quote"></a></div>
<script type="text/javascript">
    var fileName = '5664633';
    var commentscount = 0;
    var islock = false
</script>
<script type="text/javascript" src="http://static.blog.csdn.net/scripts/comment.js"></script>
<div id="ad_bot"></div>
<script type="text/javascript">
    new Ad(5, 'ad_bot');
</script>
<div id="report_dialog"></div>

<div id="d-top" style="display:none;">
<a id="d-top-a" href="#" title="回到顶部">
<img src="http://static.blog.csdn.net/images/top.png" alt="TOP" /></a>
</div>
<script type="text/javascript">
    $(function(){
        var d_top=$('#d-top');
        document.onscroll=function(){
            var scrTop=(document.body.scrollTop||document.documentElement.scrollTop);
            if(scrTop>500){
                d_top.show();
            }else{
                d_top.hide();
            }
        }
        $('#d-top-a').click(function(){
            scrollTo(0,0);
            this.blur();
            return false;
        });
    });
</script>

<div class="clear"></div>
</div>
</div>

<div id="side">
<div class="side">
<div id="panel_Profile" class="panel">
<ul class="panel_head"><span>个人资料</span></ul>
<ul class="panel_body profile">
<div id="blog_userface">
    <a href="http://my.csdn.net/superbeck" target="_blank">
    <img src="http://avatar.csdn.net/5/C/A/1_superbeck.jpg" title="访问我的空间" style="max-width:90%"/>
    </a>
    <br />
    <span><a href="http://my.csdn.net/superbeck" class="user_name" target="_blank">superbeck</a></span>
</div>
<div class="interact">
<a href="javascript:void(0);" class="attent" id="span_add_follow" title="[加关注]"></a>
<a href="javascript:void(0);" class="letter" onclick="loginto(1)" title="[发私信]"></a>
</div>
<div id="blog_medal">
</div>
<ul id="blog_rank">
    <li>访问：<span>93915次</span></li>
    <li>积分：<span>1765分</span></li>
    <li>排名：<span>第5120名</span></li>
</ul>
<ul id="blog_statistics">
    <li>原创：<span>72篇</span></li>
    <li>转载：<span>20篇</span></li>
    <li>译文：<span>1篇</span></li>
    <li>评论：<span>45条</span></li>
</ul>
</ul>
</div>

<div class="panel">
<ul class="panel_body" style="padding:0;">
<script type="text/javascript" src="http://cbjs.baidu.com/js/m.js"></script> 
<script type="text/javascript"> 
BAIDU_CLB_preloadSlots("724643","117306"); 
</script>
<script type="text/javascript">BAIDU_CLB_fillSlot("724643");</script> 
</ul>
</div>
<div class="panel" id="panel_Search">
    <ul class="panel_head"><span>文章搜索</span></ul>
    <ul class="panel_body">
        <form id="frmSearch" action="http://so.csdn.net/search" class="form_search" target="_blank">
        <span><input id="inputSearch" type="text" class="blogsearch" title="请输入关键字" /></span>
        <input id="btnSubmit" type="submit" value="搜索" title="search in blog" />
        <input type="hidden" name="q" id="inputQ" />
        <input type="hidden" name="t" value="blog" />
        <a id="btnSearchBlog" target="_blank"></a>
        </form>
    </ul>
</div><div id="panel_Category" class="panel">
<ul class="panel_head"><span>文章分类</span></ul>
<ul class="panel_body">
<li>
<a href="http://blog.csdn.net/superbeck/article/category/551445">Database</a><span>(2)</span>
</li>
<li>
<a href="http://blog.csdn.net/superbeck/article/category/494146">eclipse</a><span>(7)</span>
</li>
<li>
<a href="http://blog.csdn.net/superbeck/article/category/207307">java</a><span>(27)</span>
</li>
<li>
<a href="http://blog.csdn.net/superbeck/article/category/417007">Life</a><span>(5)</span>
</li>
<li>
<a href="http://blog.csdn.net/superbeck/article/category/487521">notes开发</a><span>(2)</span>
</li>
<li>
<a href="http://blog.csdn.net/superbeck/article/category/590316">python</a><span>(1)</span>
</li>
<li>
<a href="http://blog.csdn.net/superbeck/article/category/744229">ubuntu/linux</a><span>(0)</span>
</li>
<li>
<a href="http://blog.csdn.net/superbeck/article/category/708356">Velocity</a><span>(1)</span>
</li>
<li>
<a href="http://blog.csdn.net/superbeck/article/category/547684">Web开发</a><span>(22)</span>
</li>
<li>
<a href="http://blog.csdn.net/superbeck/article/category/412477">开发工具相关</a><span>(28)</span>
</li>
<li>
<a href="http://blog.csdn.net/superbeck/article/category/451648">开发杂想</a><span>(13)</span>
</li>
<li>
<a href="http://blog.csdn.net/superbeck/article/category/490099">设计/UML/MDA</a><span>(13)</span>
</li>
<li>
<a href="http://blog.csdn.net/superbeck/article/category/473096">软件工程</a><span>(6)</span>
</li>
</ul>
</div><div id="panel_Archive" class="panel">
<ul class="panel_head"><span>文章存档</span></ul>
<ul class="panel_body">
<div id="archive_list">
<!--归档统计-->
<li><a href="http://blog.csdn.net/superbeck/article/month/2011/04">2011年04月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2011/02">2011年02月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2010/11">2010年11月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2010/10">2010年10月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2010/09">2010年09月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2010/07">2010年07月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2010/06">2010年06月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2010/05">2010年05月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2010/03">2010年03月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2010/02">2010年02月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2010/01">2010年01月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2009/11">2009年11月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2009/10">2009年10月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2009/09">2009年09月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2009/08">2009年08月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2009/07">2009年07月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2009/06">2009年06月</a><span>(9)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2009/05">2009年05月</a><span>(6)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2009/03">2009年03月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2009/02">2009年02月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2009/01">2009年01月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2008/12">2008年12月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2008/11">2008年11月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2008/10">2008年10月</a><span>(8)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2008/09">2008年09月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2008/08">2008年08月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2008/06">2008年06月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2006/11">2006年11月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2006/10">2006年10月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/superbeck/article/month/2006/05">2006年05月</a><span>(1)</span></li>
</div>
</ul>
</div>
<div id="hotarticls" class="panel">
<ul class="panel_head"><span>阅读排行</span></ul>
<ul class="panel_body itemlist">
<li>
<a href="/superbeck/article/details/5721382" title="eclipse上的几个Velocity插件">eclipse上的几个Velocity插件</a><span>(7394)</span>
</li>
<li>
<a href="/superbeck/article/details/4359870" title="Ant:给Ant脚本传递参数的最佳实践">Ant:给Ant脚本传递参数的最佳实践</a><span>(4790)</span>
</li>
<li>
<a href="/superbeck/article/details/4446177" title="设计模式：简单工厂、工厂方法、抽象工厂之小结与区别">设计模式：简单工厂、工厂方法、抽象工厂之小结与区别</a><span>(3877)</span>
</li>
<li>
<a href="/superbeck/article/details/4799407" title="基于java的程序OutOfMemory问题的解决及Xms/Xmx/Xss的解释和应用">基于java的程序OutOfMemory问题的解决及Xms/Xmx/Xss的解释和应用</a><span>(3805)</span>
</li>
<li>
<a href="/superbeck/article/details/3983671" title="程序员兼职创收的新方法 - 依托平台开发应用">程序员兼职创收的新方法 - 依托平台开发应用</a><span>(3587)</span>
</li>
<li>
<a href="/superbeck/article/details/4532818" title="python学习——初次接触(python,wxpython,Boa,py2exe)">python学习——初次接触(python,wxpython,Boa,py2exe)</a><span>(3483)</span>
</li>
<li>
<a href="/superbeck/article/details/3226709" title="一次cygwin的绿化 - 顺便多学一些脚本/注册表的知识">一次cygwin的绿化 - 顺便多学一些脚本/注册表的知识</a><span>(3171)</span>
</li>
<li>
<a href="/superbeck/article/details/5325991" title="设计模式：Visitor模式">设计模式：Visitor模式</a><span>(2511)</span>
</li>
<li>
<a href="/superbeck/article/details/4247145" title="使用Hibernate连接MySQL数据库发生closed.Connection问题的一种解决方法">使用Hibernate连接MySQL数据库发生closed.Connection问题的一种解决方法</a><span>(2254)</span>
</li>
<li>
<a href="/superbeck/article/details/4247066" title="如何用Java实现MySQL数据库的备份和恢复">如何用Java实现MySQL数据库的备份和恢复</a><span>(2124)</span>
</li>
</ul>
</div>
<div id="hotarticls2" class="panel">
<ul class="panel_head"><span>评论排行</span></ul>
<ul class="panel_body itemlist">
<li>
<a href="/superbeck/article/details/4323861" title="StarUML: 插件加载失败的解决方法">StarUML: 插件加载失败的解决方法</a><span>(11)</span>
</li>
<li>
<a href="/superbeck/article/details/4213095" title="使用jstl1.1，注意与1.0的区别">使用jstl1.1，注意与1.0的区别</a><span>(5)</span>
</li>
<li>
<a href="/superbeck/article/details/4446177" title="设计模式：简单工厂、工厂方法、抽象工厂之小结与区别">设计模式：简单工厂、工厂方法、抽象工厂之小结与区别</a><span>(5)</span>
</li>
<li>
<a href="/superbeck/article/details/4247925" title="displaytag的properties文件的汉化-displaytag_zh_CN.properties">displaytag的properties文件的汉化-displaytag_zh_CN.properties</a><span>(3)</span>
</li>
<li>
<a href="/superbeck/article/details/3226709" title="一次cygwin的绿化 - 顺便多学一些脚本/注册表的知识">一次cygwin的绿化 - 顺便多学一些脚本/注册表的知识</a><span>(2)</span>
</li>
<li>
<a href="/superbeck/article/details/5325991" title="设计模式：Visitor模式">设计模式：Visitor模式</a><span>(2)</span>
</li>
<li>
<a href="/superbeck/article/details/5721382" title="eclipse上的几个Velocity插件">eclipse上的几个Velocity插件</a><span>(2)</span>
</li>
<li>
<a href="/superbeck/article/details/4247145" title="使用Hibernate连接MySQL数据库发生closed.Connection问题的一种解决方法">使用Hibernate连接MySQL数据库发生closed.Connection问题的一种解决方法</a><span>(2)</span>
</li>
<li>
<a href="/superbeck/article/details/5969884" title="设计模式：Bridge模式">设计模式：Bridge模式</a><span>(2)</span>
</li>
<li>
<a href="/superbeck/article/details/2575212" title="浏览器的刷新和确定按钮的功能">浏览器的刷新和确定按钮的功能</a><span>(2)</span>
</li>
</ul>
</div>
<div id="homepageArticles" class="panel">
<ul class="panel_head"><span>推荐文章</span></ul>
<ul class="panel_body" id="ad_commend"></ul>
</div>
<script type="text/javascript">
 new Ad(12, 'ad_commend');
</script><div id="newcomments" class="panel">
<ul class="panel_head"><span>最新评论</span></ul>
<ul class="panel_body itemlist">
    <li>
    <a href="/superbeck/article/details/4323861#comments">StarUML: 插件加载失败的解决方法</a>
    <p style="margin:0px;"><a href="/zhanshanyou" class="user_name">zhanshanyou</a>:
解决问题的好文章，多谢！
    </p>
    </li>
    <li>
    <a href="/superbeck/article/details/5325991#comments">设计模式：Visitor模式</a>
    <p style="margin:0px;"><a href="/qyongkang" class="user_name">qyongkang</a>:
写的好，终于看懂了
    </p>
    </li>
    <li>
    <a href="/superbeck/article/details/4247925#comments">displaytag的properties文件的汉化-displaytag_zh_CN.properties</a>
    <p style="margin:0px;"><a href="/seeyou339621438" class="user_name">seeyou339621438</a>:
嗯，我也是看了你的文章才解决了问题！非常感谢。
    </p>
    </li>
    <li>
    <a href="/superbeck/article/details/5325991#comments">设计模式：Visitor模式</a>
    <p style="margin:0px;"><a href="/sheismylife" class="user_name">sheismylife</a>:
写的挺好。我已经快忘记Visitor了，看了你的UML图马上想起来了。
    </p>
    </li>
    <li>
    <a href="/superbeck/article/details/5721382#comments">eclipse上的几个Velocity插件</a>
    <p style="margin:0px;"><a href="/Wuaner" class="user_name">Wuaner</a>:
你说的 g &amp; s 上的 Veloeclipse，是完全一样的，没有任何区别，只是作者闲的没事同时上...
    </p>
    </li>
    <li>
    <a href="/superbeck/article/details/4213095#comments">使用jstl1.1，注意与1.0的区别</a>
    <p style="margin:0px;"><a href="/usx09325_" class="user_name">usx09325_</a>:
顶顶
    </p>
    </li>
    <li>
    <a href="/superbeck/article/details/4446177#comments">设计模式：简单工厂、工厂方法、抽象工厂之小结与区别</a>
    <p style="margin:0px;"><a href="/lxxxxl" class="user_name">lxxxxl</a>:
“简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力）”我认为简单工厂模式...
    </p>
    </li>
    <li>
    <a href="/superbeck/article/details/1344230#comments">eclipse中安装插件的几种方法</a>
    <p style="margin:0px;"><a href="/bingyingao" class="user_name">bingyingao</a>:
mark一下
    </p>
    </li>
    <li>
    <a href="/superbeck/article/details/4446177#comments">设计模式：简单工厂、工厂方法、抽象工厂之小结与区别</a>
    <p style="margin:0px;"><a href="/elance_123" class="user_name">elance_123</a>:
文中提到的“产品类可以是多种形式，多层继承或者是单个类都是可以的”，是否可以解释一下“多层继承或者是...
    </p>
    </li>
    <li>
    <a href="/superbeck/article/details/4247066#comments">如何用Java实现MySQL数据库的备份和恢复</a>
    <p style="margin:0px;"><a href="/mjm88132" class="user_name">mjm88132</a>:
`111
    </p>
    </li>
</ul>
</div>
<div id="custom_column_968473" class="panel">
<ul class="panel_head"><span>useful link</span></ul>
<ul class="panel_body">
<ul><li><a href="www.download.com" target=_blank>免费软件(英文)</a></li><li><a href="www.open-open.com" target=_blank>开源大全</a></li><li><a href="www.sourceforge.net" target=_blank>source forge</a></li><li><a href="www.java2s.com" target=_blank>www.java2s.com</a></li><li><a href="http://www.w3schools.com/" target=_blank>http://www.w3schools.com/</a></li></ul>
</ul>
</div></div>
<div class="clear"></div>
</div>

<div class="clear"></div>
</div>

<script type="text/javascript" src="http://static.blog.csdn.net/scripts/newblog.min.js?v=1.1"></script>
<script type="text/javascript" src="http://medal.blog.csdn.net/showblogmedal.ashx?blogid=129278"></script>

<script type="text/javascript">
document.write('<script type="text/javascript" src="http://csdnimg.cn/pubfooter/js/publib_footer.js?' + Math.floor(new Date()/120000).toString(36) + '="></'+'script>');
</script>

<script type="text/javascript" src="http://passport.csdn.net/content/loginbox/login.js"></script>
<script type="text/javascript">document.write("<img src=http://counter.csdn.net/pv.aspx?id=24 border=0 width=0 height=0>");</script>
<script type="text/javascript" src="http://www.csdn.net/ui/scripts/Csdn/counter.js?v=1"></script>


<script type="text/javascript" src="http://ad.csdn.net/scripts/ad-blog.js"></script>

<script type="text/javascript" src="http://zz.csdn.net/js/count.js"></script>

</div>
</body>
</html>